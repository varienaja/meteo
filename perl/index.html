<!DOCTYPE html>
<html lang="en-US">

<meta charset="UTF-8">

<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.9/angular.min.js"></script>
<body>




<!--
TODO: insert interpolations, if we don't have a measurement for every 10-minute timeslice
TODO: Show moments of last rain, last sunshine, last time above 30, last time above 20, last time below 0?
TODO: Make minimum/maximum for sunshine and precipitation tiles first and last measurement.
TODO: Show all kinds of interactive and self-updating thingies: top-x lists; 

TODO: List all stations, so we can see this page for all stations.
TODO: when reloading all measurements, do not filter by station, so we can keep/update min/max for all stations and list top-3 of those under the 7 tiles?
Loading measurements for all stations is expensive (lots of data, lots of unused measurements)
Better: load top10 from server, refresh every now and then?
TODO: Records since yesterday
TODO: Extremes of today

-->

<div class="all" ng-app="myApp" ng-controller="weatherController">

<style>
.legend {
  text-anchor: end;
}

@media (min-width: 0px) {
  .small {
     display: none;
  }
}

@media (min-width: 1300px) {
  .small {
     display: initial;
  }
}

div {
  float: left;
}
#container {
	display: flex;
	gap: 4px;
}
.all {
  width: 100%;
}
.right {
  width: {{legendwidth}}px;
}
.left {
  width: {{legendwidth}}px;
}
.middle {
  width: calc(100% - {{2*legendwidth}}px);
}
</style>

<h2>Measurements in {{code}} on {{currentdate | date:'dd-MM-yyyy'}} {{formatTime(currenthh, currentmm)}} {{forecastlocation}}</h2>
<!-- SVG -->

<div class="left">
	<svg width="100%" height={{graphheight}}>
		<rect x=0 y=0 width=100% height=100% fill=lightgray></rect>
		<text class="legend" x="40" y="15">°C</text>
		<!-- TODO if height is different: adapt repeat thingy. -->
		<text ng-repeat="i in [30,60,90,120,150,180,210]" class="legend" x="40" y={{i+5}}>{{(i-150)/-3}}</text>
	</svg>
</div>

<div class="middle">
	<svg width=100% height={{graphheight}}>
		<rect x=0 y=0 width=100% height=100% fill=lightgray></rect>
		<style>
			rect:hover {stroke: blue}
			circle:hover {stroke: red}
		</style>
		<line x1=0% y1=0 x2=0% y2=240 stroke=gray />
		<line x1=100% y1=0 x2=100% y2=240 stroke=gray />
		<line x1=0% y1={{i}} x2=100% y2={{i}} stroke=gray ng-repeat="i in [0,30,60,90,120,150,180,210]"/>
		<line x1={{i*100/24}}% y1=0 x2={{i*100/24}}% y2=210 stroke=gray ng-repeat="i in [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]"/>
		<text x={{i*100/24}}% y=240 text-anchor=middle ng-repeat="i in [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]"><tspan>{{i}}</tspan><tspan class=small>:00</tspan></text>

		<!-- forecasts (only for PSI at the moment, since it must be linked to a postal code which is only hardcoded to 5303 at the moment) -->
		<g ng-if="code == 'PSI'">
			<!-- Wind forecast -->
			<g stroke=green stroke-dasharray="1,2">
				<line x1="{{toX(measurements['km/h'].at(-1).hh, measurements['km/h'].at(-1).mm)}}" x2="{{toXUnix(forecast.wind.data[0][0])}}" y1="{{210-measurements['km/h'].at(-1).value*1.5}}" y2="{{210-forecast.wind.data[0][1]*1.5}}"></line> <!-- connect measurement with forecast -->
				<line ng-repeat="x in forecast.wind.data" ng-hide="$first" x1="{{toXUnix(forecast.wind.data[$index-1][0])}}" x2="{{toXUnix(x[0])}}" y1="{{210-forecast.wind.data[$index-1][1]*1.5}}" y2="{{210-x[1]*1.5}}"></line>
			</g>
			<!-- Temperature forecast -->
			<g stroke=red stroke-dasharray="1,2">
				<line x1="{{toX(measurements['°C'].at(-1).hh, measurements['°C'].at(-1).mm)}}" x2="{{toXUnix(forecast.temperature[0][0])}}" y1="{{150-measurements['°C'].at(-1).value*3}}" y2="{{150-forecast.temperature[0][1]*3}}"></line> <!-- connect measurement with forecast -->
				<line ng-repeat="x in forecast.temperature" ng-hide="$first" x1="{{toXUnix(forecast.temperature[$index-1][0])}}" x2="{{toXUnix(x[0])}}" y1="{{150-forecast.temperature[$index-1][1]*3}}" y2="{{150-x[1]*3}}"></line>
			</g>
			<!-- Sunshine forecast -->
			<g fill=yellow opacity=40% stroke-dasharray="1,2">
				<rect x="{{toXUnix(x[0] - x[1]/2*60*1000)}}" y="202" height="8" width="{{x[1]/14.4}}%" ng-repeat="x in forecast.sunshine"><title>Prediction: {{x[1]}} minutes of sunshine</title></rect> <!-- shift measurements to the left by value (x[1]) minutes divided by 2, so the bar is centered around the time of the prediction -->
			</g>
			<!-- Precipitation forecast -->
			<g fill=blue opacity=40%>
				<rect x="{{toXUnix(x[0])}}" y="202" height={{x[1]*60}} width=".5%" ng-repeat="x in forecast.rainfall"><title>Prediction: {{x[1]}}mm rainfall</title></rect>
			</g>

			<!-- sunset + sunrise -->
			<text text-anchor=middle x={{toXUnix(forecast.sunrise)}} y=222>🔺<title>Sunrise {{toTimeUnix(forecast.sunrise)}}</title></text>
			<text text-anchor=middle x={{toXUnix(forecast.sunset)}} y=222>🔻<title>Sunset {{toTimeUnix(forecast.sunset)}}</title></text>
		</g>


		<!-- Sunshine --> <!-- TODO shift sunhine left for (10-value)/2 minutes, so the bars are nicely centered around the timestamp -->
		<rect x="{{100/24*(x.hh+x.mm/60) - 1/3}}%" y="202" height="8" width="{{x.value/14.4}}%" fill=yellow ng-repeat="x in measurements['min']"><title>{{formatTime(x.hh, x.mm)}} {{x.value}}{{x.unit}}</title></rect>

		<!-- Radiation -->
		<rect x="{{100/24*(x.hh+x.mm/60) - 28/100}}%" y="1" height={{x.value*.12}} width=".5%" fill=orange ng-repeat="x in measurements['W/m²']"><title>{{formatTime(x.hh, x.mm)}} {{x.value}}{{x.unit}}</title></rect>

		<!-- Precipitation -->
		<rect x="{{100/24*(x.hh+x.mm/60) - 28/100}}%" y="{{210 - x.value*60}}" height={{x.value*60}} width=".5%" fill=blue ng-repeat="x in measurements['mm']"><title>{{formatTime(x.hh, x.mm)}} {{x.value}}{{x.unit}}</title></rect>

		<!-- Pressure -->
		<line ng-repeat="x in measurements['hPa']" ng-hide="$first" x1="{{toX(measurements['hPa'][$index-1].hh, measurements['hPa'][$index-1].mm)}}" x2="{{toX(x.hh,x.mm)}}" y1="{{330-measurements['hPa'][$index-1].value*.3}}" y2="{{330-x.value*.3}}" stroke=black></line>
		<circle cx="{{toX(x.hh, x.mm)}}" cy={{330-x.value*.3}} r="2" fill=black ng-repeat="x in measurements['hPa']"><title>{{formatTime(x.hh, x.mm)}} {{x.value}}{{x.unit}}</title></circle>

		<!-- Humidity -->
		<line ng-repeat="x in measurements['%']" ng-hide="$first" x1="{{toX(measurements['%'][$index-1].hh, measurements['%'][$index-1].mm)}}" x2="{{toX(x.hh,x.mm)}}" y1="{{150-measurements['%'][$index-1].value*1.5}}" y2="{{150-x.value*1.5}}" stroke=deepskyblue></line>
		<circle cx="{{toX(x.hh, x.mm)}}" cy={{150-x.value*1.5}} r="{{2 + (x.value==minmax['%'].min || x.value==minmax['%'].max ? 1 : 0)}}" fill=deepskyblue ng-repeat="x in measurements['%']"><title>{{formatTime(x.hh, x.mm)}} {{x.value}}{{x.unit}}</title></circle>
		<line x1="100%" y1="{{150-minmax['%'].min*1.5}}" x2="100%" y2="{{150-minmax['%'].max*1.5}}" stroke=deepskyblue stroke-width=8><title>Humidity: {{minmax['%'].min}}...{{minmax['%'].max}}%</title></line>

		<!-- Wind -->
		<line ng-repeat="x in measurements['km/h']" ng-hide="$first" x1="{{toX(measurements['km/h'][$index-1].hh, measurements['km/h'][$index-1].mm)}}" x2="{{toX(x.hh,x.mm)}}" y1="{{210-measurements['km/h'][$index-1].value*1.5}}" y2="{{210-x.value*1.5}}" stroke=green></line>
		<circle cx="{{toX(x.hh, x.mm)}}" cy={{210-x.value*1.5}} r="{{3 + (x.value==minmax['km/h'].min || x.value==minmax['km/h'].max ? 1 : 0)}}" fill=green ng-repeat="x in measurements['km/h']"><title>{{formatTime(x.hh, x.mm)}} {{x.value}}{{x.unit}}</title></circle>
		<line x1="100%" y1="{{210-minmax['km/h'].min*1.5}}" x2="100%" y2="{{210-minmax['km/h'].max*1.5}}" stroke=green stroke-width=8><title>Wind: {{minmax['km/h'].min}}...{{minmax['km/h'].max}}km/h</title></line>

		<!-- Temperature -->
		<line ng-repeat="x in measurements['°C']" ng-hide="$first" x1="{{toX(measurements['°C'][$index-1].hh, measurements['°C'][$index-1].mm)}}" x2="{{toX(x.hh,x.mm)}}" y1="{{150-measurements['°C'][$index-1].value*3}}" y2="{{150-x.value*3}}" stroke=red></line>
		<circle cx="{{toX(x.hh, x.mm)}}" cy={{150-x.value*3}} r="{{3 + (x.value==minmax['°C'].min || x.value==minmax['°C'].max ? 1 : 0)}}" fill=red ng-repeat="x in measurements['°C']"><title>{{formatTime(x.hh, x.mm)}} {{x.value}}{{x.unit}}</title></circle>
		<line x1="1" y1="{{150-minmax['°C'].min*3}}" x2="1" y2="{{150-minmax['°C'].max*3}}" stroke=red stroke-width=8><title>Temperature: {{minmax['°C'].min}}...{{minmax['°C'].max}}°C</title></line>
	</svg>
</div>

<div class="right">
	<svg width="100%" height={{graphheight}}>
		<rect x=0 y=0 width=100% height=100% fill=lightgray></rect>
		<text class="legend" x="100%" y="15">km/h</text>
		<text ng-repeat="i in [30,60,90,120,150,180,210]" class="legend" x="100%" y={{i+5}}>{{2*(i-210)/-3}}</text>
	</svg>
</div>

<div id="container"><div ng-repeat='(key,value) in minmax' class="tile">
	<svg width="100%" height="5.8vw">
		<rect x=0 y=0 width=100% height=100% fill=lightgray></rect>
		<g ng-if="['°C','km/h','%','hPa'].indexOf(key)>=0">
			<circle cx=90% cy=1em r=3 fill={{unit2properties[key].colour}}></circle>
			<circle cx=95% cy=1em r=3 fill={{unit2properties[key].colour}}></circle>
			<line x1=90% x2=95% y1=1em y2=1em stroke={{unit2properties[key].colour}}></line>
		</g>
		<g ng-if="['W/m²','min','mm'].indexOf(key)>=0">
			<rect x=90% y=5 height=15 width=5% fill={{unit2properties[key].colour}}></circle>
		</g>
		<text y=1em font-size=2.5vw>{{unit2properties[key].icon}}</text>
		<text>
			<tspan x=50% dy="1em" text-anchor="middle" font-size=1vw>{{unit2properties[key].desc}}</tspan>
			<tspan x=50% dy="1em" text-anchor="middle" font-size=1.7vw>{{formatTile(key, value.sum, measurements[key].at(-1).value)}}</tspan>
		</text>

		<text y=100% font-size=1vw>
			<tspan x=3 dy=-1.6em>{{value.min}}{{key}}</tspan><tspan x=3 dy=1.2em font-weight="{{isMin(key, measurements[key].at(-1).value) ? 'Bold' : 'Normal'}}">{{formatTime(value.hhmin, value.mmmin)}}</tspan>
		</text>
		<text y=100% x=50% text-anchor="middle" font-size=1vw ng-if="['min','mm'].indexOf(key)==-1">
			<tspan dy=-0.4em>{{value.sum / value.count | number: 1}}{{key}}</tspan>
		</text>
		<text y=100% text-anchor="end" font-size=1vw>
		<tspan x=100% dy=-1.6em>{{value.max}}{{key}}</tspan><tspan x=100% dy=1.2em font-weight="{{isMax(key, measurements[key].at(-1).value) ? 'Bold' : 'Normal'}}">{{formatTime(value.hhmax, value.mmmax)}}</tspan>
		</text>
	</svg>
</div></div>

<h2>New records since yesterday</h2>
<table>
	<tr><th colspan=2>Type</th><th colspan=2>Station</th><th>m/m</th><th>Time</th><th colspan=2>Value</th><th>Age</th></tr>

	<tr ng-repeat='r in records'>
		<td align=center>{{unit2properties[r.unit].icon}}</td>
		<td>{{unit2properties[r.unit].desc}}</td>
		<td><a href="?code={{r.code}}">{{r.code}}</a></td>
		<td>{{r.name}}</td>
		<td>{{r.type}}</td>
		<td>{{r.moment}}</td>
		<td align=right>{{r.recordvalue}}</td>
		<td>{{r.unit}}</td>
		<td align=right>{{r.age}}</td>
	</tr>
</table>

<!--
TODO: Extremes of today which is initially filled by a query, subsequently updated by inspecting measurements from all stations every 10 minutes.
records of today, week, month, year, all time

temp: min, max, highest minimum, smalles maximum
wind: min, max, highest minimum, smalles maximum
no humidity, pressure, radiation?
sunshine: highest sum, lowest sum
precipitation: sum, highest sum, lowest sum?
-->

<script>
var app = angular.module('myApp', []);
app.controller('weatherController', 
	function($scope, $http, $interval, $location) {
		$scope.formatTime = function(hh, mm) {
			if (typeof hh === "undefined") {
				return "";
			}
			var result = hh + ":";
			if (mm < 10) {
				result += "0";
			}
			result += mm.toFixed(0);
			return result;
		}

		$scope.toX = function(hh, mm) { // {{100/24*(x.hh+x.mm/60)}}%
			return 100/24*(hh+mm/60) + "%";
		}

		$scope.toXUnix = function(tt) {
			var dd = new Date(tt);
			return 100/24*(dd.getHours()+dd.getMinutes()/60) + "%";
		}

		$scope.toTimeUnix = function(tt) {
			var dd = new Date(tt);
			return $scope.formatTime(dd.getHours(), dd.getMinutes());
		}

		$scope.isMin = function(key, value) { //
			if (typeof value === "undefined") {
				return false;
			}
			return $scope.minmax[key].min == value;
		}

		$scope.isMax = function(key, value) { //
			if (typeof value === "undefined") {
				return false;
			}
			return $scope.minmax[key].max == value;
		}

		$scope.formatTile = function(key, sum, value) {
			if (key === "mm") {
				return sum.toFixed(1) + key;
			}
			if (typeof value === "undefined") {
				return "n.a.";
			}
			if (key === "min") {
				return $scope.formatTime(Math.floor(sum / 60), sum % 60);
			}
			if (key === "W/m²") {
				return value + key;
			}
			return value.toFixed(1) + key;
		}

		$scope.id = 0;
		$scope.code = new URL(window.location).searchParams.get("code");
		if (!$scope.code) {
			$scope.code = "PSI"; // Default
		}

		$scope.unit2properties = {
			"°C":{"desc":"Temperature", "colour":"red", "icon":"🌡"},
			"km/h":{"desc":"Windspeed", "colour":"green", "icon":"💨"},
			"%":{"desc":"Humidity", "colour": "deepskyblue", "icon":"💧"}, 
			"hPa":{"desc":"Pressure", "colour": "black", "icon":"⏲"},
			"W/m²":{"desc":"Radiation", "colour": "orange", "icon":"🔆"}, 
			"min":{"desc":"Sunshine", "colour": "yellow", "icon":"☀️"},
			"mm":{"desc":"Precipitation", "colour": "blue", "icon":"🌧"}
		};

		$scope.legendwidth = 45;
		$scope.graphheight = 244;

		retrieveMeasurements($scope, $http);
		$interval(function() {retrieveMeasurements($scope, $http)}, 60000);
	}
);

function initDay($scope, $http) {
	$scope.currentdate = new Date();
	$scope.currentdatestring = $scope.currentdate.toDateString();
	$scope.currenthh = 0;
	$scope.currentmm = 0;
	$scope.minmax = {
		"°C":{"count":0, "sum":0},
		"km/h":{"count":0, "sum":0},
		"%":{"count":0, "sum":0},
		"hPa":{"count":0, "sum":0},
		"W/m²":{"count":0, "sum":0},
		"min":{"count":0, "sum":0},
		"mm":{"count":0, "sum":0}
	};
	$scope.globalminmax = {
		"°C":{},
		"km/h":{},
		"%":{},
		"hPa":{},
		"W/m²":{},
		"min":{},
		"mm":{}
	};
	$scope.measurements = {"%":[], "°C":[],"hPa":[], "km/h":[], "W/m²":[], "min":[], "mm": []};
	retrieveDailyRecords($scope, $http);
	retrieveForecast($scope, $http);
}

function retrieveMeasurements($scope, $http) {
	let url = "stationmeasurements.pl?code=" + $scope.code + "&id=" + $scope.id;
	$http.get(url).then(function (response) {
		if ($scope.currentdatestring != new Date().toDateString()) {
			initDay($scope, $http);
		}
		for (m of response.data) {
			$scope.id = Math.max($scope.id, m.id);
			if ((m.hh + m.mm / 60) > ($scope.currenthh + $scope.currentmm / 60)) {
				$scope.currenthh = m.hh;
				$scope.currentmm = m.mm;
			}

			if (m.code == $scope.code) {
				$scope.measurements[m.unit].push(m);
				for (entry in $scope.minmax) {
					if (m.unit === entry) {
						if (!$scope.minmax[entry].min || m.value < $scope.minmax[entry].min) {
							$scope.minmax[entry].min = m.value;
							$scope.minmax[entry].hhmin = m.hh;
							$scope.minmax[entry].mmmin = m.mm;
						}
						if (!$scope.minmax[entry].max || m.value >= $scope.minmax[entry].max) {
							$scope.minmax[entry].max = m.value;
							$scope.minmax[entry].hhmax = m.hh;
							$scope.minmax[entry].mmmax = m.mm;
						}
						$scope.minmax[entry].count++;
						$scope.minmax[entry].sum += m.value;
					}
				}
			}
			document.title = "Meteo " + $scope.code + " on " + $scope.formatTime($scope.currenthh, $scope.currentmm);

//			for (entry in $scope.globalminmax) {
//				if (m.unit === entry) {
//					if (!$scope.globalminmax[entry][m.code].min || m.value < $scope.globalminmax[entry][m.code].min) {
//						$scope.globalminmax[entry][m.code].min = m.value;
//						$scope.globalminmax[entry][m.code].hhmin = m.hh;
//						$scope.globalminmax[entry][m.code].mmmin = m.mm;
//					}
//					if (!$scope.globalminmax[entry][m.code].max || m.value >= $scope.globalminmax[entry][m.code].max) {
//						$scope.globalminmax[entry][m.code].max = m.value;
//						$scope.globalminmax[entry][m.code].hhmax = m.hh;
//						$scope.globalminmax[entry][m.code].mmmax = m.mm;
//					}
//				}
//			}
		}
		trimForecast($scope);
	});
}

function retrieveDailyRecords($scope, $http) {
	let url = "newrecords.pl";
	$http.get(url).then(function (response) {
		$scope.records = response.data;
	});
}

function retrieveForecast($scope, $http) {
	if ($scope.code != "PSI") {
		return;
	}
	let url = "forecast.pl";
	$http.get(url).then(function (response) {
		$scope.forecast = response.data[0];

		// add first sample from next day to this forecast, so we see data until 24:00 instead of until 23:00
		$scope.forecast.temperature.push(response.data[1].temperature[0]);
		$scope.forecast.sunshine.push(response.data[1].sunshine[0]);
		$scope.forecast.rainfall.push(response.data[1].rainfall[0]);
		$scope.forecast.wind.data.push(response.data[1].wind.data[0]);

		// Make date be on 'today' instead of 'tomorrow' by substracting 1 millisecond
		$scope.forecast.temperature.at(-1)[0] -= 1;
		$scope.forecast.sunshine.at(-1)[0] -= 1;
		$scope.forecast.rainfall.at(-1)[0] -= 1;
		$scope.forecast.wind.data.at(-1)[0] -= 1;

		trimForecast($scope);
	});
}

function trimForecast($scope) {
	// Remove predictions older than current time.
	if ($scope.forecast) {
		let compDate = new Date();
		compDate.setHours($scope.currenthh, $scope.currentmm, 0, 0);
		$scope.forecast.temperature = $scope.forecast.temperature.filter(
			sample => new Date(sample[0]) > compDate
		);
		$scope.forecast.sunshine = $scope.forecast.sunshine.filter(
			sample => new Date(sample[0]) > compDate
		);
		$scope.forecast.rainfall = $scope.forecast.rainfall.filter(
			sample => new Date(sample[0]) > compDate
		);
		$scope.forecast.wind.data = $scope.forecast.wind.data.filter(
			sample => new Date(sample[0]) > compDate
		);
	}
}
</script>

</body>
</html> 
